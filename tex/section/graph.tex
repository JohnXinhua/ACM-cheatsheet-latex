\newpage
\section{Graph}

\subsection{Eulerian Circuit}
\lstinputlisting{../code/eulerian_circuit.cpp}

\subsection{Prime}
\lstinputlisting{../code/prime.cpp}

\subsection{Kruskal}

\lstinputlisting{../code/kruskal.cpp}

\subsection{Dijkstra}
\begin{lstlisting}
//vs start point, prev[]:previous point, dist[] distance minimum
void dijkstra(int vs, int prev[], int dist[])
{
    int i,j,k;
    int min;
    int tmp;
    bool flag[MAX];      // flag[i]=true:already treated

    for (i = 0; i < VexNum; i++)
    {
        flag[i] = false;            
        prev[i] = 0;         
        dist[i] = graph[vs][i];
    }

    flag[vs] = true;
    dist[vs] = 0;

    for (i = 1; i < VexNum; i++)
    {
        //find the nearest point of the start among all points non-visited
        min = INF;
        for (j = 0; j < mVexNum; j++)
        {
            if (!flag[j] && dist[j]<min)
            {
                min = dist[j];
                k = j;
            }
        }
        flag[k] = true;

        for (j = 0; j < mVexNum; j++)
        {
            tmp = (graph[k][j]==INF ? INF : (min + graph[k][j]));
            if (!flag[j] && (tmp  < dist[j]) )
            {
                dist[j] = tmp;
                prev[j] = k;
            }
        }
    }
}
\end{lstlisting}

\subsection{Bellman-For}
\begin{lstlisting}
/*input: matrix of the graph,origin and end
output: the shortest path from origin to end*/
bool Bellman_Ford()  
{  
    for(int i = 1; i <= nodenum; ++i)  
        dis[i] = (i == original ? 0 : MAX);  
    for(int i = 1; i <= nodenum - 1; ++i)  
        for(int j = 1; j <= edgenum; ++j)  
            if(dis[edge[j].v] > dis[edge[j].u] + edge[j].cost)  
            {  
                dis[edge[j].v] = dis[edge[j].u] + edge[j].cost;  
                pre[edge[j].v] = edge[j].u;  
            }  
    bool flag = 1; 
    //if there is a negative circuit
    for(int i = 1; i <= edgenum; ++i)  
        if(dis[edge[i].v] > dis[edge[i].u] + edge[i].cost)  
        {  
            flag = 0;  
            break;  
        }  
    return flag;  
}
\end{lstlisting}
\subsection{A*}
\subsection{Topological sort}
\begin{lstlisting}
int topologicalSort()
{
    int i,j;
    int index = 0;
    int head = 0;           // 辅助队列的头
    int rear = 0;           // 辅助队列的尾
    int *queue;             // 辅组队列
    int *ins;               // 入度数组
    char *tops;             // 拓扑排序结果数组，记录每个节点的排序后的序号。
    ENode *node;

    ins   = new int[VexNum];
    queue = new int[VexNum];
    tops  = new char[VexNum];
    memset(ins, 0, VexNum*sizeof(int));
    memset(queue, 0, VexNum*sizeof(int));
    memset(tops, 0, VexNum*sizeof(char));
	
	//calculate entering degrees
    for(i = 0; i < VexNum; i++)
    {
        node = Vexs[i].firstEdge;
        while (node != NULL)
        {
            ins[node->ivex]++;
            node = node->nextEdge;
        }
    }

    // push all points with zero entering degree
    for(i = 0; i < mVexNum; i ++)
        if(ins[i] == 0)
            queue[rear++] = i;          // 入队列

    while (head != rear)                // 队列非空
    {
        j = queue[head++];              // 出队列。j是顶点的序号
        tops[index++] = Vexs[j].data;  // 将该顶点添加到tops中，tops是排序结果
        node = mVexs[j].firstEdge;      // 获取以该顶点为起点的出边队列

        // 将与"node"关联的节点的入度减1；
        // 若减1之后，该节点的入度为0；则将该节点添加到队列中。
        while(node != NULL)
        {
            // 将节点(序号为node->ivex)的入度减1。
            ins[node->ivex]--;
            // 若节点的入度为0，则将其"入队列"
            if( ins[node->ivex] == 0)
                queue[rear++] = node->ivex;  // 入队列

            node = node->nextEdge;
        }
    }

    if(index != mVexNum)
    {
        cout << "Graph has a cycle" << endl;
        delete queue;
        delete ins;
        delete tops;
        return 1;
    }

    // 打印拓扑排序结果
    cout << "== TopSort: ";
    for(i = 0; i < mVexNum; i ++)
        cout << tops[i] << " ";
    cout << endl;

    delete queue;
    delete ins;
    delete tops;

    return 0;
}
\end{lstlisting}

\subsection{Hungary}
\begin{lstlisting}
bool dfs(int u)//从左边开始找增广路径
{
    int v;
    for(v=0;v<vN;v++)//右边顶点编号从0开始
	{
		if(g[u][v]&&!used[v])  //如果存在通路,且从u开始搜索时该点没访问过
		{
			used[v]=true;
			if(link[v]==-1 || dfs(link[v]))	//找增广路
			{
				link[v]=u;
				return true;
			}
		}
	}
    return false;
}
int hungary()
{
    int res=0;
    int i,u;
    memset(link,-1,sizeof(link));
    for(u=0;u<uN;u++)
    {
        memset(used,0,sizeof(used));
        if(dfs(u)) 
			res++;
    }
    return res;
} 
\end{lstlisting}
\subsection{Strong connected component(tarjan)}
\begin{lstlisting}
void tarjan(int i)
{
    int j;
    DFN[i]=LOW[i]=++Dindex;
    instack[i]=true;
    Stap[++Stop]=i;
    for (edge *e=V[i];e;e=e->next)
    {
        j=e->t;
        if (!DFN[j])
        {
            tarjan(j);
            if (LOW[j]<LOW[i])
                LOW[i]=LOW[j];
        }
        else if (instack[j] && DFN[j]<LOW[i])
            LOW[i]=DFN[j];
    }
    if (DFN[i]==LOW[i])
    {
        Bcnt++;
        do
        {
            j=Stap[Stop--];
            instack[j]=false;
            Belong[j]=Bcnt;
        }
        while (j!=i);
    }
}
\end{lstlisting}
\subsection{Min tree graph}
